From a0ea8e9fb1f66be1aee510cbf70e1c62b35a7c56 Mon Sep 17 00:00:00 2001
From: Shiva Kumar M S <shivakum@xilinx.com>
Date: Mon, 21 Mar 2022 12:44:52 +0530
Subject: [PATCH] VMAF integration in gst-plugins-bad 1.18.5

Signed-off-by: Shiva Kumar M S <shivakum@xilinx.com>
---
 ext/iqa/iqa-dssim.c         | 468 ++++++++++++++++++++++++++++++
 ext/iqa/iqa-dssim.h         |  42 +++
 ext/iqa/iqa-vmaf.c          | 673 ++++++++++++++++++++++++++++++++++++++++++++
 ext/iqa/iqa-vmaf.h          |  87 ++++++
 ext/iqa/iqa.c               | 522 ----------------------------------
 ext/iqa/iqa.h               |  66 -----
 ext/iqa/iqaplugin.c         |  55 ++++
 ext/iqa/libvmaf_wrapper.cpp | 127 +++++++++
 ext/iqa/libvmaf_wrapper.h   |  33 +++
 ext/iqa/meson.build         |  32 ++-
 meson.build                 |   1 +
 11 files changed, 1514 insertions(+), 592 deletions(-)
 create mode 100644 ext/iqa/iqa-dssim.c
 create mode 100644 ext/iqa/iqa-dssim.h
 create mode 100644 ext/iqa/iqa-vmaf.c
 create mode 100644 ext/iqa/iqa-vmaf.h
 delete mode 100644 ext/iqa/iqa.c
 delete mode 100644 ext/iqa/iqa.h
 create mode 100644 ext/iqa/iqaplugin.c
 create mode 100644 ext/iqa/libvmaf_wrapper.cpp
 create mode 100644 ext/iqa/libvmaf_wrapper.h

diff --git a/ext/iqa/iqa-dssim.c b/ext/iqa/iqa-dssim.c
new file mode 100644
index 0000000..bf59f56
--- /dev/null
+++ b/ext/iqa/iqa-dssim.c
@@ -0,0 +1,468 @@
+/* DSSIM Image Quality Assessment plugin
+ * Copyright (C) 2015 Mathieu Duponchelle <mathieu.duponchelle@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-iqa-dssim
+ * @title: iqa-dssim
+ * @short_description: DSSIM Image Quality Assessment plugin.
+ *
+ * iqa-dssim will perform full reference image quality assessment, with the
+ * first added pad being the reference.
+ *
+ * It will perform comparisons on video streams with the same geometry.
+ *
+ * The image output will be the heat map of differences, between
+ * the two pads with the highest measured difference.
+ *
+ * For each reference frame, iqa-dssim will post a message containing
+ * a structure named IQA-DSSIM.
+ *
+ * The message will also contain a "time" field.
+ *
+ * For example, if there are two compared streams,
+ * the emitted structure will look like this:
+ *
+ * IQA-DSSIM, dssim=(structure)"dssim\,\ sink_1\=\(double\)0.053621271267184856\,\
+ * sink_2\=\(double\)0.0082939683976297474\;",
+ * time=(guint64)0;
+ *
+ * ## Example launch line
+ * |[
+ * gst-launch-1.0 -m uridecodebin uri=file:///test/file/1 ! iqa-dssim name=iqa-dssim \
+ * ! videoconvert ! autovideosink uridecodebin uri=file:///test/file/2 ! iqa-dssim.
+ * ]| This pipeline will output messages to the console for each set of compared frames.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include "iqa-dssim.h"
+#include "dssim.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_iqadssim_debug);
+#define GST_CAT_DEFAULT gst_iqadssim_debug
+
+#define SINK_FORMATS " { AYUV, BGRA, ARGB, RGBA, ABGR, Y444, Y42B, YUY2, UYVY, "\
+                "   YVYU, I420, YV12, NV12, NV21, Y41B, RGB, BGR, xRGB, xBGR, "\
+                "   RGBx, BGRx } "
+
+#define SRC_FORMAT " { RGBA } "
+#define DEFAULT_DSSIM_ERROR_THRESHOLD -1.0
+
+static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE (SRC_FORMAT))
+    );
+
+enum
+{
+  PROP_0,
+  PROP_SSIM_ERROR_THRESHOLD,
+  PROP_MODE,
+  PROP_LAST,
+};
+
+static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink_%u",
+    GST_PAD_SINK,
+    GST_PAD_REQUEST,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE (SINK_FORMATS))
+    );
+
+/* Child proxy implementation */
+static GObject *
+gst_iqa_child_proxy_get_child_by_index (GstChildProxy * child_proxy,
+    guint index)
+{
+  GstIqa *iqa = GST_IQA (child_proxy);
+  GObject *obj = NULL;
+
+  GST_OBJECT_LOCK (iqa);
+  obj = g_list_nth_data (GST_ELEMENT_CAST (iqa)->sinkpads, index);
+  if (obj)
+    gst_object_ref (obj);
+  GST_OBJECT_UNLOCK (iqa);
+
+  return obj;
+}
+
+static guint
+gst_iqa_child_proxy_get_children_count (GstChildProxy * child_proxy)
+{
+  guint count = 0;
+  GstIqa *iqa = GST_IQA (child_proxy);
+
+  GST_OBJECT_LOCK (iqa);
+  count = GST_ELEMENT_CAST (iqa)->numsinkpads;
+  GST_OBJECT_UNLOCK (iqa);
+  GST_INFO_OBJECT (iqa, "Children Count: %d", count);
+
+  return count;
+}
+
+static void
+gst_iqa_child_proxy_init (gpointer g_iface, gpointer iface_data)
+{
+  GstChildProxyInterface *iface = g_iface;
+
+  iface->get_child_by_index = gst_iqa_child_proxy_get_child_by_index;
+  iface->get_children_count = gst_iqa_child_proxy_get_children_count;
+}
+
+/**
+ * GstIqaMode:
+ * @GST_IQA_MODE_STRICT: Strict checks of the frames is enabled, this for
+ * example implies that an error will be posted in case all the streams don't
+ * have the exact same number of frames.
+ *
+ * Since: 1.18
+ */
+typedef enum
+{
+  GST_IQA_MODE_STRICT = (1 << 1),
+} GstIqaMode;
+
+#define GST_TYPE_IQA_MODE (gst_iqa_mode_flags_get_type())
+static GType
+gst_iqa_mode_flags_get_type (void)
+{
+  static const GFlagsValue values[] = {
+    {GST_IQA_MODE_STRICT, "Strict comparison of frames.", "strict"},
+    {0, NULL, NULL}
+  };
+  static GType id = 0;
+
+  if (g_once_init_enter ((gsize *) & id)) {
+    GType _id;
+
+    _id = g_flags_register_static ("GstIqaMode", values);
+
+    g_once_init_leave ((gsize *) & id, _id);
+  }
+
+  return id;
+}
+
+/* GstIqaDssim */
+#define gst_iqadssim_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstIqaDssim, gst_iqadssim, GST_TYPE_VIDEO_AGGREGATOR,
+    G_IMPLEMENT_INTERFACE (GST_TYPE_CHILD_PROXY, gst_iqa_child_proxy_init));
+
+inline static unsigned char
+to_byte (float in)
+{
+  if (in <= 0)
+    return 0;
+  if (in >= 255.f / 256.f)
+    return 255;
+  return in * 256.f;
+}
+
+static gboolean
+compare_frames (GstIqaDssim * self, GstVideoFrame * ref, GstVideoFrame * cmp,
+    GstBuffer * outbuf, GstStructure * msg_structure, gchar * padname)
+{
+  dssim_attr *attr;
+  gint y;
+  unsigned char **ptrs, **ptrs2;
+  GstMapInfo ref_info;
+  GstMapInfo cmp_info;
+  GstMapInfo out_info;
+  dssim_image *ref_image;
+  dssim_image *cmp_image;
+  double dssim;
+  dssim_ssim_map map_meta;
+  float *map;
+  gint i;
+  dssim_rgba *out;
+  GstStructure *dssim_structure;
+  gboolean ret = TRUE;
+
+  if (ref->info.width != cmp->info.width ||
+      ref->info.height != cmp->info.height) {
+    GST_OBJECT_UNLOCK (self);
+
+    GST_ELEMENT_ERROR (self, STREAM, FAILED,
+        ("Video streams do not have the same sizes (add videoscale"
+            " and force the sizes to be equal on all sink pads.)"),
+        ("Reference width %d - compared width: %d. "
+            "Reference height %d - compared height: %d",
+            ref->info.width, cmp->info.width, ref->info.height,
+            cmp->info.height));
+
+    GST_OBJECT_LOCK (self);
+    return FALSE;
+  }
+
+  gst_structure_get (msg_structure, "dssim", GST_TYPE_STRUCTURE,
+      &dssim_structure, NULL);
+
+  attr = dssim_create_attr ();
+  dssim_set_save_ssim_maps (attr, 1, 1);
+
+  gst_buffer_map (ref->buffer, &ref_info, GST_MAP_READ);
+  gst_buffer_map (cmp->buffer, &cmp_info, GST_MAP_READ);
+  gst_buffer_map (outbuf, &out_info, GST_MAP_WRITE);
+  out = (dssim_rgba *) out_info.data;
+
+  ptrs = g_malloc (sizeof (char **) * ref->info.height);
+
+  for (y = 0; y < ref->info.height; y++) {
+    ptrs[y] = ref_info.data + (ref->info.width * 4 * y);
+  }
+
+  ref_image =
+      dssim_create_image (attr, ptrs, DSSIM_RGBA, ref->info.width,
+      ref->info.height, 0.45455);
+
+  ptrs2 = g_malloc (sizeof (char **) * cmp->info.height);
+
+  for (y = 0; y < cmp->info.height; y++) {
+    ptrs2[y] = cmp_info.data + (cmp->info.width * 4 * y);
+  }
+
+  cmp_image =
+      dssim_create_image (attr, ptrs2, DSSIM_RGBA, cmp->info.width,
+      cmp->info.height, 0.45455);
+  dssim = dssim_compare (attr, ref_image, cmp_image);
+
+  map_meta = dssim_pop_ssim_map (attr, 0, 0);
+
+  /* Comparing floats... should not be a big deal anyway */
+  if (self->ssim_threshold > 0 && dssim > self->ssim_threshold) {
+    /* We do not really care about our state... we are going to error ou
+     * anyway! */
+    GST_OBJECT_UNLOCK (self);
+
+    GST_ELEMENT_ERROR (self, STREAM, FAILED,
+        ("Dssim check failed on %s at %"
+            GST_TIME_FORMAT " with dssim %f > %f",
+            padname,
+            GST_TIME_ARGS (GST_AGGREGATOR_PAD (GST_AGGREGATOR (self)->
+                    srcpad)->segment.position), dssim, self->ssim_threshold),
+        (NULL));
+
+    GST_OBJECT_LOCK (self);
+
+    ret = FALSE;
+    goto cleanup_return;
+  }
+
+  if (dssim > self->max_dssim) {
+    map = map_meta.data;
+
+    for (i = 0; i < map_meta.width * map_meta.height; i++) {
+      const float max = 1.0 - map[i];
+      const float maxsq = max * max;
+      out[i] = (dssim_rgba) {
+      .r = to_byte (max * 3.0),.g = to_byte (maxsq * 6.0),.b =
+            to_byte (max / ((1.0 - map_meta.dssim) * 4.0)),.a = 255,};
+    }
+    self->max_dssim = dssim;
+  }
+
+  gst_structure_set (dssim_structure, padname, G_TYPE_DOUBLE, dssim, NULL);
+  gst_structure_set (msg_structure, "dssim", GST_TYPE_STRUCTURE,
+      dssim_structure, NULL);
+
+  ret = TRUE;
+
+cleanup_return:
+
+  gst_structure_free (dssim_structure);
+
+  free (map_meta.data);
+  g_free (ptrs);
+  g_free (ptrs2);
+  gst_buffer_unmap (ref->buffer, &ref_info);
+  gst_buffer_unmap (cmp->buffer, &cmp_info);
+  gst_buffer_unmap (outbuf, &out_info);
+  dssim_dealloc_image (ref_image);
+  dssim_dealloc_image (cmp_image);
+  dssim_dealloc_attr (attr);
+
+  return ret;
+}
+
+static GstFlowReturn
+gst_iqadssim_aggregate_frames (GstVideoAggregator * vagg, GstBuffer * outbuf)
+{
+  GList *l;
+  GstVideoFrame *ref_frame = NULL;
+  GstIqaDssim *self = GST_IQADSSIM (vagg);
+  GstStructure *msg_structure = gst_structure_new_empty ("IQA-DSSIM");
+  GstStructure *dssim_structure = gst_structure_new_empty ("dssim");
+  GstMessage *m = gst_message_new_element (GST_OBJECT (self), msg_structure);
+  GstAggregator *agg = GST_AGGREGATOR (vagg);
+
+  gst_structure_set (msg_structure, "dssim", GST_TYPE_STRUCTURE,
+      dssim_structure, NULL);
+  gst_structure_free (dssim_structure);
+  self->max_dssim = 0.0;
+
+  GST_OBJECT_LOCK (vagg);
+  for (l = GST_ELEMENT (vagg)->sinkpads; l; l = l->next) {
+    GstVideoAggregatorPad *pad = l->data;
+    GstVideoFrame *prepared_frame =
+        gst_video_aggregator_pad_get_prepared_frame (pad);
+
+    if (prepared_frame != NULL) {
+      if (!ref_frame) {
+        ref_frame = prepared_frame;
+      } else {
+        gboolean res;
+        gchar *padname = gst_pad_get_name (pad);
+        GstVideoFrame *cmp_frame = prepared_frame;
+
+        res = compare_frames (self, ref_frame, cmp_frame, outbuf, msg_structure,
+            padname);
+        g_free (padname);
+
+        if (!res)
+          goto failed;
+      }
+    } else if ((self->mode & GST_IQA_MODE_STRICT) && ref_frame) {
+      GST_OBJECT_UNLOCK (vagg);
+
+      GST_ELEMENT_ERROR (self, STREAM, FAILED,
+          ("All sources are supposed to have the same number of buffers"
+              " but got no buffer matching %" GST_PTR_FORMAT " on pad: %"
+              GST_PTR_FORMAT, outbuf, pad), (NULL));
+
+      GST_OBJECT_LOCK (vagg);
+      break;
+    }
+  }
+
+  GST_OBJECT_UNLOCK (vagg);
+
+  /* We only post the message here, because we can't post it while the object
+   * is locked.
+   */
+  gst_structure_set (msg_structure, "time", GST_TYPE_CLOCK_TIME,
+      GST_AGGREGATOR_PAD (agg->srcpad)->segment.position, NULL);
+  gst_element_post_message (GST_ELEMENT (self), m);
+  return GST_FLOW_OK;
+
+failed:
+  GST_OBJECT_UNLOCK (vagg);
+
+  return GST_FLOW_ERROR;
+}
+
+static void
+_set_property (GObject * object, guint prop_id, const GValue * value,
+    GParamSpec * pspec)
+{
+  GstIqaDssim *self = GST_IQADSSIM (object);
+
+  switch (prop_id) {
+    case PROP_SSIM_ERROR_THRESHOLD:
+      GST_OBJECT_LOCK (self);
+      self->ssim_threshold = g_value_get_double (value);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    case PROP_MODE:
+      GST_OBJECT_LOCK (self);
+      self->mode = g_value_get_flags (value);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstIqaDssim *self = GST_IQADSSIM (object);
+
+  switch (prop_id) {
+    case PROP_SSIM_ERROR_THRESHOLD:
+      GST_OBJECT_LOCK (self);
+      g_value_set_double (value, self->ssim_threshold);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    case PROP_MODE:
+      GST_OBJECT_LOCK (self);
+      g_value_set_flags (value, self->mode);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+/* GObject boilerplate */
+static void
+gst_iqadssim_class_init (GstIqaDssimClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstVideoAggregatorClass *videoaggregator_class =
+      (GstVideoAggregatorClass *) klass;
+
+  videoaggregator_class->aggregate_frames = gst_iqadssim_aggregate_frames;
+
+  gst_element_class_add_static_pad_template_with_gtype (gstelement_class,
+      &src_factory, GST_TYPE_AGGREGATOR_PAD);
+  gst_element_class_add_static_pad_template_with_gtype (gstelement_class,
+      &sink_factory, GST_TYPE_VIDEO_AGGREGATOR_CONVERT_PAD);
+
+  gobject_class->set_property = _set_property;
+  gobject_class->get_property = _get_property;
+
+  g_object_class_install_property (gobject_class, PROP_SSIM_ERROR_THRESHOLD,
+      g_param_spec_double ("dssim-error-threshold", "dssim error threshold",
+          "dssim value over which the element will post an error message on the bus."
+          " A value < 0.0 means 'disabled'.",
+          -1.0, G_MAXDOUBLE, DEFAULT_DSSIM_ERROR_THRESHOLD, G_PARAM_READWRITE));
+
+  /**
+   * iqa:mode:
+   *
+   * Controls the frame comparison mode.
+   *
+   * Since: 1.18
+   */
+  g_object_class_install_property (gobject_class, PROP_MODE,
+      g_param_spec_flags ("mode", "IQA mode",
+          "Controls the frame comparison mode.", GST_TYPE_IQA_MODE,
+          0, G_PARAM_READWRITE));
+
+  gst_type_mark_as_plugin_api (GST_TYPE_IQA_MODE, 0);
+
+  gst_element_class_set_static_metadata (gstelement_class, "iqa-dssim",
+      "Filter/Analyzer/Video",
+      "Provides various Image Quality Assessment metrics",
+      "Mathieu Duponchelle <mathieu.duponchelle@collabora.co.uk>");
+
+  GST_DEBUG_CATEGORY_INIT (gst_iqadssim_debug, "iqa", 0, "iqa-dssim");
+}
+
+static void
+gst_iqadssim_init (GstIqaDssim * self)
+{
+}
diff --git a/ext/iqa/iqa-dssim.h b/ext/iqa/iqa-dssim.h
new file mode 100644
index 0000000..b0deeb1
--- /dev/null
+++ b/ext/iqa/iqa-dssim.h
@@ -0,0 +1,42 @@
+/* Image Quality Assessment plugin
+ * Copyright (C) 2015 Mathieu Duponchelle <mathieu.duponchelle@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_IQADSSIM_H__
+#define __GST_IQADSSIM_H__
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideoaggregator.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_IQADSSIM (gst_iqadssim_get_type())
+G_DECLARE_FINAL_TYPE(GstIqaDssim, gst_iqadssim, GST, IQADSSIM, GstVideoAggregator)
+
+struct _GstIqaDssim
+{
+  GstVideoAggregator videoaggregator;
+
+  gdouble ssim_threshold;
+  gdouble max_dssim;
+  gint mode;
+};
+
+G_END_DECLS
+#endif /* __GST_IQADSSIM_H__ */
diff --git a/ext/iqa/iqa-vmaf.c b/ext/iqa/iqa-vmaf.c
new file mode 100644
index 0000000..4a12d24
--- /dev/null
+++ b/ext/iqa/iqa-vmaf.c
@@ -0,0 +1,673 @@
+/* VMAF Image Quality Assessment plugin
+ * Copyright (C) 2019 Sergey Zvezdakov <szvezdakov@graphics.cs.msu.ru>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-iqa-vmaf
+ * @title: iqa-vmaf
+ * @short_description: VMAF Image Quality Assessment plugin.
+ *
+ * iqa-vmaf will perform full reference image quality assessment, with the
+ * first added pad being the reference.
+ *
+ * It will perform comparisons on video streams with the same geometry.
+ *
+ * The image output will be a copy of the reference pad.
+ *
+ * The plugin requires a model file with pretrained LibSVM coefficients.
+ * By default, plugin search file with "vmaf_v0.6.1.pkl" filename.
+ * You can set the absolute path to the model file using
+ * 'model-filename' property.
+ *
+ * For each reference frame, iqa-vmaf will post a message containing
+ * a structure named IQA-VMAF. Important note: All messages with per-frame results will
+ * be posted after EOS because of libvmaf mechanisms.
+ *
+ * For example, if there is one compared stream,
+ * the emitted structure will look like this:
+ *
+ * IQA-VMAF, padname=(string)sink_1, frame_num=(uint)0, metrics=(structure)"metrics\,\
+ * adm2\=\(double\)0.96487284080576141\,\ motion2\=\(double\)0\,\
+ * vif_scale0\=\(double\)0.43687698390868496\,\ vif_scale1\=\(double\)0.90850678076133007\,\
+ * vif_scale2\=\(double\)0.95736908154084577\,\ vif_scale3\=\(double\)0.97432499094076475\,\
+ * vmaf\=\(double\)86.273788213561033\;";
+ *
+ * ## Example launch line
+ * |[
+ * gst-launch-1.0 -m uridecodebin uri=file:///test/file/1 ! iqa-vmaf name=iqa-vmaf \
+ * ! videoconvert ! autovideosink uridecodebin uri=file:///test/file/2 ! iqa-vmaf.
+ * ]| This pipeline will output messages to the console for each set of compared frames.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include "libvmaf_wrapper.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_iqavmaf_debug);
+#define GST_CAT_DEFAULT gst_iqavmaf_debug
+#define SINK_FORMATS " { I420, YV12, Y41B, Y42B, Y444, I420_10LE, I422_10LE, Y444_10LE } "
+#define SRC_FORMAT " { I420, YV12, Y41B, Y42B, Y444, I420_10LE, I422_10LE, Y444_10LE } "
+#define DEFAULT_MODEL_FILENAME   "vmaf_v0.6.1.pkl"
+#define DEFAULT_DISABLE_CLIP     FALSE
+#define DEFAULT_DISABLE_AVX      FALSE
+#define DEFAULT_ENABLE_TRANSFORM FALSE
+#define DEFAULT_PHONE_MODEL      FALSE
+#define DEFAULT_PSNR             FALSE
+#define DEFAULT_SSIM             FALSE
+#define DEFAULT_MS_SSIM          FALSE
+#define DEFAULT_POOL_METHOD      MEAN_POOL_METHOD
+#define DEFAULT_NUM_THREADS      0
+#define DEFAULT_SUBSAMPLE        1
+#define DEFAULT_CONF_INT         FALSE
+#define GST_TYPE_IQAVMAF_POOL_METHOD (gst_iqavmaf_pool_method_get_type ())
+
+static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE (SRC_FORMAT))
+    );
+
+enum
+{
+  PROP_0,
+  PROP_MODEL_FILENAME,
+  PROP_DISABLE_CLIP,
+  PROP_DISABLE_AVX,
+  PROP_ENABLE_TRANSFORM,
+  PROP_PHONE_MODEL,
+  PROP_PSNR,
+  PROP_SSIM,
+  PROP_MS_SSIM,
+  PROP_POOL_METHOD,
+  PROP_NUM_THREADS,
+  PROP_SUBSAMPLE,
+  PROP_CONF_INT,
+  PROP_LAST,
+};
+
+enum VMAFReadFuncRetCodes
+{
+  VMAF_SUCCESSFUL_READING = 0,
+  VMAF_READING_FAILED = 2
+};
+
+
+static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink_%u",
+    GST_PAD_SINK,
+    GST_PAD_REQUEST,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE (SINK_FORMATS))
+    );
+
+static GType
+gst_iqavmaf_pool_method_get_type (void)
+{
+  static const GEnumValue types[] = {
+    {MIN_POOL_METHOD, "Minimum value", "min"},
+    {MEAN_POOL_METHOD, "Arithmetic mean", "mean"},
+    {HARMONIC_MEAN_POOL_METHOD, "Harmonic mean", "harmonic_mean"},
+    {0, NULL, NULL},
+  };
+  static gsize id = 0;
+
+  if (g_once_init_enter (&id)) {
+    GType _id = g_enum_register_static ("GstIqaVmafPoolMethod", types);
+    g_once_init_leave (&id, _id);
+  }
+
+  return (GType) id;
+}
+
+
+/* GstIqaVmaf */
+
+static inline float
+get_data_from_ptr (void *ptr, int i, int j, int frame_width, gboolean y10bit)
+{
+  float result;
+  if (y10bit)
+    result = (float) ((guint16 *) ptr)[i * frame_width + j] / 4.0;
+  else
+    result = (float) ((guint8 *) ptr)[i * frame_width + j];
+  return result;
+}
+
+static int
+read_frame (float *ref_data, float *main_data, float *temp_data,
+    int stride, void *h)
+{
+  GstIqaVmafThreadHelper *helper = (GstIqaVmafThreadHelper *) h;
+  int ret;
+  GstIqaVmafQueueElem *frames_data;
+  frames_data = g_async_queue_pop (helper->frame_queue);
+  if (frames_data->original_ptr && frames_data->distorted_ptr) {
+    int i, j;
+    float *ref_ptr = ref_data;
+    float *main_ptr = main_data;
+    for (i = 0; i < helper->frame_height; i++) {
+      for (j = 0; j < helper->frame_width; j++) {
+        ref_ptr[j] = get_data_from_ptr (frames_data->original_ptr, i, j,
+            helper->frame_width, helper->y10bit);
+        main_ptr[j] = get_data_from_ptr (frames_data->distorted_ptr, i, j,
+            helper->frame_width, helper->y10bit);
+      }
+      ref_ptr += stride / sizeof (*ref_data);
+      main_ptr += stride / sizeof (*ref_data);
+    }
+    ret = VMAF_SUCCESSFUL_READING;
+  } else {
+    ret = VMAF_READING_FAILED;
+  }
+  if (frames_data) {
+    g_free (frames_data->original_ptr);
+    g_free (frames_data->distorted_ptr);
+  }
+  g_free (frames_data);
+  return ret;
+}
+
+#define gst_iqavmaf_parent_class parent_class
+G_DEFINE_TYPE (GstIqaVmaf, gst_iqavmaf, GST_TYPE_VIDEO_AGGREGATOR);
+
+static void
+vmaf_thread_call (void *vs)
+{
+  GstIqaVmafThreadHelper *helper;
+  gboolean thread_is_stopped = FALSE;
+  gboolean ret_status;
+  if (vs == NULL)
+    return;
+  helper = (GstIqaVmafThreadHelper *) vs;
+  g_mutex_lock (&helper->check_thread_failure);
+  thread_is_stopped = helper->thread_failure;
+  g_mutex_unlock (&helper->check_thread_failure);
+  if (thread_is_stopped)
+    return;
+  ret_status = RunVMAF (read_frame, vs, helper);
+  g_mutex_lock (&helper->check_thread_failure);
+  helper->thread_failure = !ret_status;
+  g_mutex_unlock (&helper->check_thread_failure);
+  if (helper->error_msg)
+    GST_ELEMENT_ERROR (helper->gst_iqavmaf_p, RESOURCE, FAILED,
+        ("Launhing LibVMAF error: %s", helper->error_msg),
+        ("Launhing LibVMAF error: %s", helper->error_msg));
+}
+
+static gboolean
+try_thread_stop (GstTask * thread)
+{
+  GstTaskState task_state;
+  gboolean result;
+  task_state = gst_task_get_state (thread);
+  if (task_state == GST_TASK_STARTED) {
+    result = gst_task_stop (thread);
+  } else {
+    result = TRUE;
+  }
+  return result;
+}
+
+static gboolean
+compare_frames (GstIqaVmaf * self, GstVideoFrame * ref, GstVideoFrame * cmp,
+    GstBuffer * outbuf, GstIqaVmafThreadHelper * thread_data)
+{
+  gboolean result;
+  GstMapInfo ref_info;
+  GstMapInfo cmp_info;
+  GstMapInfo out_info;
+  gint frames_size;
+  GstIqaVmafQueueElem *frames_data;
+  // Check that thread is waiting
+  g_mutex_lock (&thread_data->check_thread_failure);
+  if (thread_data->thread_failure) {
+    try_thread_stop (thread_data->vmaf_thread);
+    return FALSE;
+  }
+  g_mutex_unlock (&thread_data->check_thread_failure);
+  // Run reading
+  gst_buffer_map (ref->buffer, &ref_info, GST_MAP_READ);
+  gst_buffer_map (cmp->buffer, &cmp_info, GST_MAP_READ);
+  gst_buffer_map (outbuf, &out_info, GST_MAP_WRITE);
+
+  frames_size = thread_data->frame_height * thread_data->frame_width;
+  if (thread_data->y10bit)
+    frames_size *= 2;
+
+  frames_data = g_malloc (sizeof (GstIqaVmafQueueElem));
+  frames_data->original_ptr = g_memdup (ref_info.data, frames_size);
+  frames_data->distorted_ptr = g_memdup (cmp_info.data, frames_size);
+
+  g_async_queue_push (thread_data->frame_queue, frames_data);
+
+  g_mutex_lock (&thread_data->check_thread_failure);
+  if (!thread_data->thread_failure) {
+    gint i;
+    result = TRUE;
+    for (i = 0; i < ref_info.size; i++) {
+      out_info.data[i] = ref_info.data[i];
+    }
+  } else {
+    try_thread_stop (thread_data->vmaf_thread);
+    result = FALSE;
+  }
+  g_mutex_unlock (&thread_data->check_thread_failure);
+  gst_buffer_unmap (ref->buffer, &ref_info);
+  gst_buffer_unmap (cmp->buffer, &cmp_info);
+  gst_buffer_unmap (outbuf, &out_info);
+  return result;
+}
+
+static GstFlowReturn
+gst_iqavmaf_aggregate_frames (GstVideoAggregator * vagg, GstBuffer * outbuf)
+{
+  GList *l;
+  GstVideoFrame *ref_frame = NULL;
+  GstIqaVmaf *self = GST_IQAVMAF (vagg);
+  gboolean res = TRUE;
+  guint stream_index = 0;
+
+  GST_OBJECT_LOCK (vagg);
+  for (l = GST_ELEMENT (vagg)->sinkpads; l; l = l->next) {
+    GstVideoAggregatorPad *pad = l->data;
+    GstVideoFrame *prepared_frame =
+        gst_video_aggregator_pad_get_prepared_frame (pad);
+
+    if (prepared_frame != NULL) {
+      if (!ref_frame) {
+        ref_frame = prepared_frame;
+      } else {
+        GstIqaVmafThreadHelper *thread_data =
+            &self->helper_struct_pointer[stream_index];
+        GstVideoFrame *cmp_frame = prepared_frame;
+
+        res &= compare_frames (self, ref_frame, cmp_frame, outbuf, thread_data);
+
+        ++stream_index;
+      }
+    }
+  }
+  if (!res)
+    goto failed;
+  GST_OBJECT_UNLOCK (vagg);
+
+  return GST_FLOW_OK;
+
+failed:
+  GST_OBJECT_UNLOCK (vagg);
+
+  return GST_FLOW_ERROR;
+}
+
+static void
+gst_iqavmaf_set_pool_method (GstIqaVmaf * self, gint pool_method)
+{
+  switch (pool_method) {
+    case MIN_POOL_METHOD:
+      self->pool_method = MIN_POOL_METHOD;
+      break;
+    case MEAN_POOL_METHOD:
+      self->pool_method = MEAN_POOL_METHOD;
+      break;
+    case HARMONIC_MEAN_POOL_METHOD:
+      self->pool_method = HARMONIC_MEAN_POOL_METHOD;
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+}
+
+static void
+_set_property (GObject * object, guint prop_id, const GValue * value,
+    GParamSpec * pspec)
+{
+  GstIqaVmaf *self = GST_IQAVMAF (object);
+
+  GST_OBJECT_LOCK (self);
+  switch (prop_id) {
+    case PROP_MODEL_FILENAME:
+      g_free (self->model_filename);
+      self->model_filename = g_value_dup_string (value);
+      break;
+    case PROP_DISABLE_CLIP:
+      self->vmaf_config_disable_clip = g_value_get_boolean (value);
+      break;
+    case PROP_DISABLE_AVX:
+      self->vmaf_config_disable_avx = g_value_get_boolean (value);
+      break;
+    case PROP_ENABLE_TRANSFORM:
+      self->vmaf_config_enable_transform = g_value_get_boolean (value);
+      break;
+    case PROP_PHONE_MODEL:
+      self->vmaf_config_phone_model = g_value_get_boolean (value);
+      break;
+    case PROP_PSNR:
+      self->vmaf_config_psnr = g_value_get_boolean (value);
+      break;
+    case PROP_SSIM:
+      self->vmaf_config_ssim = g_value_get_boolean (value);
+      break;
+    case PROP_MS_SSIM:
+      self->vmaf_config_ms_ssim = g_value_get_boolean (value);
+      break;
+    case PROP_POOL_METHOD:
+      gst_iqavmaf_set_pool_method (self, g_value_get_enum (value));
+      break;
+    case PROP_NUM_THREADS:
+      self->num_threads = g_value_get_uint (value);
+      break;
+    case PROP_SUBSAMPLE:
+      self->subsample = g_value_get_uint (value);
+      break;
+    case PROP_CONF_INT:
+      self->vmaf_config_conf_int = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+  GST_OBJECT_UNLOCK (self);
+}
+
+static void
+_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstIqaVmaf *self = GST_IQAVMAF (object);
+
+  GST_OBJECT_LOCK (self);
+  switch (prop_id) {
+    case PROP_MODEL_FILENAME:
+      g_value_set_string (value, self->model_filename);
+      break;
+    case PROP_DISABLE_CLIP:
+      g_value_set_boolean (value, self->vmaf_config_disable_clip);
+      break;
+    case PROP_DISABLE_AVX:
+      g_value_set_boolean (value, self->vmaf_config_disable_avx);
+      break;
+    case PROP_ENABLE_TRANSFORM:
+      g_value_set_boolean (value, self->vmaf_config_enable_transform);
+      break;
+    case PROP_PHONE_MODEL:
+      g_value_set_boolean (value, self->vmaf_config_phone_model);
+      break;
+    case PROP_PSNR:
+      g_value_set_boolean (value, self->vmaf_config_psnr);
+      break;
+    case PROP_SSIM:
+      g_value_set_boolean (value, self->vmaf_config_ssim);
+      break;
+    case PROP_MS_SSIM:
+      g_value_set_boolean (value, self->vmaf_config_ms_ssim);
+      break;
+    case PROP_POOL_METHOD:
+      g_value_set_enum (value, self->pool_method);
+      break;
+    case PROP_NUM_THREADS:
+      g_value_set_uint (value, self->num_threads);
+      break;
+    case PROP_SUBSAMPLE:
+      g_value_set_uint (value, self->subsample);
+      break;
+    case PROP_CONF_INT:
+      g_value_set_boolean (value, self->vmaf_config_conf_int);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+  GST_OBJECT_UNLOCK (self);
+}
+
+/* GObject boilerplate */
+
+static void
+gst_iqavmaf_init (GstIqaVmaf * self)
+{
+  GValue tmp = G_VALUE_INIT;
+  g_value_init (&tmp, G_TYPE_STRING);
+  g_value_set_static_string (&tmp, DEFAULT_MODEL_FILENAME);
+  self->model_filename = g_value_dup_string (&tmp);
+  self->vmaf_config_disable_clip = DEFAULT_DISABLE_CLIP;
+  self->vmaf_config_disable_avx = DEFAULT_DISABLE_AVX;
+  self->vmaf_config_enable_transform = DEFAULT_ENABLE_TRANSFORM;
+  self->vmaf_config_phone_model = DEFAULT_PHONE_MODEL;
+  self->vmaf_config_psnr = DEFAULT_PSNR;
+  self->vmaf_config_ssim = DEFAULT_SSIM;
+  self->vmaf_config_ms_ssim = DEFAULT_MS_SSIM;
+  gst_iqavmaf_set_pool_method (self, DEFAULT_POOL_METHOD);
+  self->num_threads = DEFAULT_NUM_THREADS;
+  self->subsample = DEFAULT_SUBSAMPLE;
+  self->vmaf_config_conf_int = DEFAULT_CONF_INT;
+  g_mutex_init (&self->finish_mutex);
+}
+
+static void
+gst_iqavmaf_finalize (GObject * object)
+{
+  GstIqaVmaf *self = GST_IQAVMAF (object);
+
+  g_mutex_clear (&self->finish_mutex);
+
+  g_free (self->model_filename);
+  self->model_filename = NULL;
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_iqavmaf_negotiated_src_caps (GstAggregator * agg, GstCaps * caps)
+{
+  GstIqaVmaf *self = GST_IQAVMAF (agg);
+  gint width, height;
+  const gchar *format;
+  gboolean y10bit;
+  GList *sinkpads_list = GST_ELEMENT (agg)->sinkpads;
+  GstStructure *caps_structure = gst_caps_get_structure (caps, 0);
+
+  gst_structure_get_int (caps_structure, "height", &height);
+  gst_structure_get_int (caps_structure, "width", &width);
+  format = gst_structure_get_string (caps_structure, "format");
+  y10bit = g_str_has_suffix (format, "_10LE");
+
+  self->number_of_vmaf_threads = g_list_length (GST_ELEMENT (agg)->sinkpads);
+  --self->number_of_vmaf_threads;       // Without reference
+  sinkpads_list = sinkpads_list->next;  // Skip reference
+
+  self->finish_threads = FALSE;
+
+  self->helper_struct_pointer =
+      g_malloc (sizeof (GstIqaVmafThreadHelper) * self->number_of_vmaf_threads);
+  for (guint i = 0; i < self->number_of_vmaf_threads; ++i) {
+    self->helper_struct_pointer[i].gst_iqavmaf_p = self;
+    self->helper_struct_pointer[i].thread_failure = FALSE;
+    self->helper_struct_pointer[i].frame_height = height;
+    self->helper_struct_pointer[i].frame_width = width;
+    self->helper_struct_pointer[i].y10bit = y10bit;
+    self->helper_struct_pointer[i].error_msg = NULL;
+    self->helper_struct_pointer[i].padname =
+        gst_pad_get_name (sinkpads_list->data);
+    sinkpads_list = sinkpads_list->next;
+
+    self->helper_struct_pointer[i].frame_queue = g_async_queue_new ();
+
+    g_mutex_init (&self->helper_struct_pointer[i].check_thread_failure);
+    g_rec_mutex_init (&self->helper_struct_pointer[i].vmaf_thread_mutex);
+    self->helper_struct_pointer[i].vmaf_thread = gst_task_new (vmaf_thread_call,
+        (void *) &self->helper_struct_pointer[i], NULL);
+    gst_task_set_lock (self->helper_struct_pointer[i].vmaf_thread,
+        &self->helper_struct_pointer[i].vmaf_thread_mutex);
+    gst_task_start (self->helper_struct_pointer[i].vmaf_thread);
+  }
+  return GST_AGGREGATOR_CLASS (parent_class)->negotiated_src_caps (agg, caps);
+}
+
+static void
+gst_iqavmaf_stop_plugin (GstAggregator * aggregator)
+{
+  GstIqaVmafThreadHelper *helper;
+  GstIqaVmaf *self = GST_IQAVMAF (aggregator);
+  g_mutex_lock (&self->finish_mutex);
+  if (!self->finish_threads) {
+    for (int i = 0; i < self->number_of_vmaf_threads; ++i) {
+      gboolean thread_failure;
+      helper = &self->helper_struct_pointer[i];
+      g_mutex_lock (&helper->check_thread_failure);
+      thread_failure = helper->thread_failure;
+      g_mutex_unlock (&helper->check_thread_failure);
+      if (thread_failure) {
+        gint q_length = g_async_queue_length (helper->frame_queue);
+        for (gint i = 0; i < q_length; ++i) {
+          GstIqaVmafQueueElem *frames_data;
+          frames_data = g_async_queue_pop (helper->frame_queue);
+          if (frames_data) {
+            g_free (frames_data->original_ptr);
+            g_free (frames_data->distorted_ptr);
+            g_free (frames_data);
+          }
+        }
+      } else {
+        GstIqaVmafQueueElem *frames_data;
+        frames_data = g_malloc (sizeof (GstIqaVmafQueueElem));
+        frames_data->original_ptr = NULL;
+        frames_data->distorted_ptr = NULL;
+        g_async_queue_push (helper->frame_queue, frames_data);
+      }
+    }
+    for (int i = 0; i < self->number_of_vmaf_threads; ++i) {
+      helper = &self->helper_struct_pointer[i];
+      gst_task_join (helper->vmaf_thread);
+      g_free (helper->error_msg);
+      g_free (helper->padname);
+      gst_object_unref (helper->vmaf_thread);
+      g_rec_mutex_clear (&helper->vmaf_thread_mutex);
+      g_mutex_clear (&helper->check_thread_failure);
+      g_async_queue_unref (helper->frame_queue);
+    }
+    g_free (self->helper_struct_pointer);
+    self->finish_threads = TRUE;
+  }
+  g_mutex_unlock (&self->finish_mutex);
+}
+
+static gboolean
+gst_iqavmaf_sink_event (GstAggregator * aggregator,
+    GstAggregatorPad * aggregator_pad, GstEvent * event)
+{
+  if (GST_EVENT_TYPE (event) == GST_EVENT_EOS)
+    gst_iqavmaf_stop_plugin (aggregator);
+  return GST_AGGREGATOR_CLASS (parent_class)->sink_event (aggregator,
+      aggregator_pad, event);
+}
+
+static gboolean
+gst_iqavmaf_stop (GstAggregator * aggregator)
+{
+  gst_iqavmaf_stop_plugin (aggregator);
+  return TRUE;
+}
+
+static void
+gst_iqavmaf_class_init (GstIqaVmafClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstVideoAggregatorClass *videoaggregator_class =
+      (GstVideoAggregatorClass *) klass;
+  GstAggregatorClass *aggregator_class = (GstAggregatorClass *) klass;
+
+  videoaggregator_class->aggregate_frames = gst_iqavmaf_aggregate_frames;
+
+  gst_element_class_add_static_pad_template_with_gtype (gstelement_class,
+      &src_factory, GST_TYPE_AGGREGATOR_PAD);
+  gst_element_class_add_static_pad_template_with_gtype (gstelement_class,
+      &sink_factory, GST_TYPE_VIDEO_AGGREGATOR_CONVERT_PAD);
+
+  aggregator_class->sink_event = gst_iqavmaf_sink_event;
+  aggregator_class->negotiated_src_caps = gst_iqavmaf_negotiated_src_caps;
+  aggregator_class->stop = gst_iqavmaf_stop;
+
+  gobject_class->set_property = GST_DEBUG_FUNCPTR (_set_property);
+  gobject_class->get_property = GST_DEBUG_FUNCPTR (_get_property);
+  gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_iqavmaf_finalize);
+
+  g_object_class_install_property (gobject_class, PROP_MODEL_FILENAME,
+      g_param_spec_string ("model-filename", "model-filename",
+          "Model *.pkl abs filename", DEFAULT_MODEL_FILENAME,
+          G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_DISABLE_CLIP,
+      g_param_spec_boolean ("disable-clip", "disable-clip",
+          "Disable clipping VMAF values", DEFAULT_DISABLE_CLIP,
+          G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_DISABLE_AVX,
+      g_param_spec_boolean ("disable-avx", "disable-avx",
+          "Disable AVX intrinsics using", DEFAULT_DISABLE_AVX,
+          G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_ENABLE_TRANSFORM,
+      g_param_spec_boolean ("enable-transform", "enable-transform",
+          "Enable transform VMAF scores", DEFAULT_ENABLE_TRANSFORM,
+          G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_PHONE_MODEL,
+      g_param_spec_boolean ("phone-model", "phone-model",
+          "Use VMAF phone model", DEFAULT_PHONE_MODEL, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_PSNR,
+      g_param_spec_boolean ("psnr", "psnr",
+          "Estimate PSNR", DEFAULT_PSNR, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_SSIM,
+      g_param_spec_boolean ("ssim", "ssim",
+          "Estimate SSIM", DEFAULT_SSIM, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_MS_SSIM,
+      g_param_spec_boolean ("ms-ssim", "ms-ssim",
+          "Estimate MS-SSIM", DEFAULT_MS_SSIM, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_POOL_METHOD,
+      g_param_spec_enum ("pool-method", "pool-method",
+          "Pool method for mean", GST_TYPE_IQAVMAF_POOL_METHOD,
+          DEFAULT_POOL_METHOD,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_NUM_THREADS,
+      g_param_spec_uint ("threads", "threads",
+          "The number of threads",
+          0, 32, DEFAULT_NUM_THREADS, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_SUBSAMPLE,
+      g_param_spec_uint ("subsample", "subsample",
+          "Computing on one of every N frames",
+          1, 128, DEFAULT_SUBSAMPLE, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_CONF_INT,
+      g_param_spec_boolean ("conf-interval", "conf-interval",
+          "Enable confidence intervals", DEFAULT_CONF_INT, G_PARAM_READWRITE));
+
+  gst_element_class_set_static_metadata (gstelement_class, "iqa-vmaf",
+      "Filter/Analyzer/Video",
+      "Provides Video Multi-Method Assessment Fusion metric",
+      "Sergey Zvezdakov <szvezdakov@graphics.cs.msu.ru>");
+  GST_DEBUG_CATEGORY_INIT (gst_iqavmaf_debug, "iqa", 0, "iqa-vmaf");
+}
diff --git a/ext/iqa/iqa-vmaf.h b/ext/iqa/iqa-vmaf.h
new file mode 100644
index 0000000..d9f5ed7
--- /dev/null
+++ b/ext/iqa/iqa-vmaf.h
@@ -0,0 +1,87 @@
+/* VMAF Image Quality Assessment plugin
+ * Copyright (C) 2019 Sergey Zvezdakov <szvezdakov@graphics.cs.msu.ru>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_IQAVMAF_H__
+#define __GST_IQAVMAF_H__
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideoaggregator.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_IQAVMAF (gst_iqavmaf_get_type())
+G_DECLARE_FINAL_TYPE(GstIqaVmaf, gst_iqavmaf, GST, IQAVMAF, GstVideoAggregator)
+
+typedef enum _GstIqaVmafPoolMethodEnum
+{
+  MIN_POOL_METHOD = 0,
+  MEAN_POOL_METHOD = 1,
+  HARMONIC_MEAN_POOL_METHOD = 2
+} GstIqaVmafPoolMethodEnum;
+
+typedef struct {
+  void *original_ptr;
+  void *distorted_ptr;
+} GstIqaVmafQueueElem;
+
+typedef struct {
+  GstIqaVmaf *gst_iqavmaf_p;
+  GstTask *vmaf_thread;
+  GRecMutex vmaf_thread_mutex;
+  GAsyncQueue *frame_queue;
+  GMutex check_thread_failure;
+  gboolean thread_failure;
+  gchar *error_msg;
+  gint frame_height;
+  gint frame_width;
+  gboolean y10bit;
+  gchar *padname;
+} GstIqaVmafThreadHelper;
+
+/**
+ * GstIqaVmaf:
+ *
+ * The opaque #GstIqaVmaf structure.
+ */
+struct _GstIqaVmaf
+{
+  GstVideoAggregator videoaggregator;
+  // VMAF settings from cmd
+  gchar *model_filename;
+  gboolean vmaf_config_disable_clip;
+  gboolean vmaf_config_disable_avx;
+  gboolean vmaf_config_enable_transform;
+  gboolean vmaf_config_phone_model;
+  gboolean vmaf_config_psnr;
+  gboolean vmaf_config_ssim;
+  gboolean vmaf_config_ms_ssim;
+  GstIqaVmafPoolMethodEnum pool_method;
+  guint num_threads;
+  guint subsample;
+  gboolean vmaf_config_conf_int;
+  // Thread helpers
+  GstIqaVmafThreadHelper *helper_struct_pointer;
+  gint number_of_vmaf_threads;
+  gboolean finish_threads;
+  GMutex finish_mutex;
+};
+
+G_END_DECLS
+#endif /* __GST_IQAVMAF_H__ */
diff --git a/ext/iqa/iqa.c b/ext/iqa/iqa.c
deleted file mode 100644
index 7cc45b8..0000000
--- a/ext/iqa/iqa.c
+++ /dev/null
@@ -1,522 +0,0 @@
-/* Image Quality Assessment plugin
- * Copyright (C) 2015 Mathieu Duponchelle <mathieu.duponchelle@collabora.co.uk>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- */
-
-/**
- * SECTION:element-iqa
- * @title: iqa
- * @short_description: Image Quality Assessment plugin.
- *
- * IQA will perform full reference image quality assessment, with the
- * first added pad being the reference.
- *
- * It will perform comparisons on video streams with the same geometry.
- *
- * The image output will be the heat map of differences, between
- * the two pads with the highest measured difference.
- *
- * For each reference frame, IQA will post a message containing
- * a structure named IQA.
- *
- * The only metric supported for now is "dssim", which will be available
- * if https://github.com/pornel/dssim was installed on the system
- * at the time that plugin was compiled.
- *
- * For each metric activated, this structure will contain another
- * structure, named after the metric.
- *
- * The message will also contain a "time" field.
- *
- * For example, if do-dssim is set to true, and there are
- * two compared streams, the emitted structure will look like this:
- *
- * IQA, dssim=(structure)"dssim\,\ sink_1\=\(double\)0.053621271267184856\,\
- * sink_2\=\(double\)0.0082939683976297474\;",
- * time=(guint64)0;
- *
- * ## Example launch line
- * |[
- * gst-launch-1.0 -m uridecodebin uri=file:///test/file/1 ! iqa name=iqa do-dssim=true \
- * ! videoconvert ! autovideosink uridecodebin uri=file:///test/file/2 ! iqa.
- * ]| This pipeline will output messages to the console for each set of compared frames.
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "iqa.h"
-
-#ifdef HAVE_DSSIM
-#include "dssim.h"
-#endif
-
-GST_DEBUG_CATEGORY_STATIC (gst_iqa_debug);
-#define GST_CAT_DEFAULT gst_iqa_debug
-
-#define SINK_FORMATS " { AYUV, BGRA, ARGB, RGBA, ABGR, Y444, Y42B, YUY2, UYVY, "\
-                "   YVYU, I420, YV12, NV12, NV21, Y41B, RGB, BGR, xRGB, xBGR, "\
-                "   RGBx, BGRx } "
-
-#define SRC_FORMAT " { RGBA } "
-#define DEFAULT_DSSIM_ERROR_THRESHOLD -1.0
-
-static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
-    GST_PAD_SRC,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE (SRC_FORMAT))
-    );
-
-enum
-{
-  PROP_0,
-  PROP_DO_SSIM,
-  PROP_SSIM_ERROR_THRESHOLD,
-  PROP_MODE,
-  PROP_LAST,
-};
-
-static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink_%u",
-    GST_PAD_SINK,
-    GST_PAD_REQUEST,
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE (SINK_FORMATS))
-    );
-
-/* Child proxy implementation */
-static GObject *
-gst_iqa_child_proxy_get_child_by_index (GstChildProxy * child_proxy,
-    guint index)
-{
-  GstIqa *iqa = GST_IQA (child_proxy);
-  GObject *obj = NULL;
-
-  GST_OBJECT_LOCK (iqa);
-  obj = g_list_nth_data (GST_ELEMENT_CAST (iqa)->sinkpads, index);
-  if (obj)
-    gst_object_ref (obj);
-  GST_OBJECT_UNLOCK (iqa);
-
-  return obj;
-}
-
-static guint
-gst_iqa_child_proxy_get_children_count (GstChildProxy * child_proxy)
-{
-  guint count = 0;
-  GstIqa *iqa = GST_IQA (child_proxy);
-
-  GST_OBJECT_LOCK (iqa);
-  count = GST_ELEMENT_CAST (iqa)->numsinkpads;
-  GST_OBJECT_UNLOCK (iqa);
-  GST_INFO_OBJECT (iqa, "Children Count: %d", count);
-
-  return count;
-}
-
-static void
-gst_iqa_child_proxy_init (gpointer g_iface, gpointer iface_data)
-{
-  GstChildProxyInterface *iface = g_iface;
-
-  iface->get_child_by_index = gst_iqa_child_proxy_get_child_by_index;
-  iface->get_children_count = gst_iqa_child_proxy_get_children_count;
-}
-
-/**
- * GstIqaMode:
- * @GST_IQA_MODE_STRICT: Strict checks of the frames is enabled, this for
- * example implies that an error will be posted in case all the streams don't
- * have the exact same number of frames.
- *
- * Since: 1.18
- */
-typedef enum
-{
-  GST_IQA_MODE_STRICT = (1 << 1),
-} GstIqaMode;
-
-#define GST_TYPE_IQA_MODE (gst_iqa_mode_flags_get_type())
-static GType
-gst_iqa_mode_flags_get_type (void)
-{
-  static const GFlagsValue values[] = {
-    {GST_IQA_MODE_STRICT, "Strict comparison of frames.", "strict"},
-    {0, NULL, NULL}
-  };
-  static GType id = 0;
-
-  if (g_once_init_enter ((gsize *) & id)) {
-    GType _id;
-
-    _id = g_flags_register_static ("GstIqaMode", values);
-
-    g_once_init_leave ((gsize *) & id, _id);
-  }
-
-  return id;
-}
-
-/* GstIqa */
-#define gst_iqa_parent_class parent_class
-G_DEFINE_TYPE_WITH_CODE (GstIqa, gst_iqa, GST_TYPE_VIDEO_AGGREGATOR,
-    G_IMPLEMENT_INTERFACE (GST_TYPE_CHILD_PROXY, gst_iqa_child_proxy_init));
-
-#ifdef HAVE_DSSIM
-inline static unsigned char
-to_byte (float in)
-{
-  if (in <= 0)
-    return 0;
-  if (in >= 255.f / 256.f)
-    return 255;
-  return in * 256.f;
-}
-
-static gboolean
-do_dssim (GstIqa * self, GstVideoFrame * ref, GstVideoFrame * cmp,
-    GstBuffer * outbuf, GstStructure * msg_structure, gchar * padname)
-{
-  dssim_attr *attr;
-  gint y;
-  unsigned char **ptrs, **ptrs2;
-  GstMapInfo ref_info;
-  GstMapInfo cmp_info;
-  GstMapInfo out_info;
-  dssim_image *ref_image;
-  dssim_image *cmp_image;
-  double dssim;
-  dssim_ssim_map map_meta;
-  float *map;
-  gint i;
-  dssim_rgba *out;
-  GstStructure *dssim_structure;
-  gboolean ret = TRUE;
-
-  if (ref->info.width != cmp->info.width ||
-      ref->info.height != cmp->info.height) {
-    GST_OBJECT_UNLOCK (self);
-
-    GST_ELEMENT_ERROR (self, STREAM, FAILED,
-        ("Video streams do not have the same sizes (add videoscale"
-            " and force the sizes to be equal on all sink pads.)"),
-        ("Reference width %d - compared width: %d. "
-            "Reference height %d - compared height: %d",
-            ref->info.width, cmp->info.width, ref->info.height,
-            cmp->info.height));
-
-    GST_OBJECT_LOCK (self);
-    return FALSE;
-  }
-
-  gst_structure_get (msg_structure, "dssim", GST_TYPE_STRUCTURE,
-      &dssim_structure, NULL);
-
-  attr = dssim_create_attr ();
-  dssim_set_save_ssim_maps (attr, 1, 1);
-
-  gst_buffer_map (ref->buffer, &ref_info, GST_MAP_READ);
-  gst_buffer_map (cmp->buffer, &cmp_info, GST_MAP_READ);
-  gst_buffer_map (outbuf, &out_info, GST_MAP_WRITE);
-  out = (dssim_rgba *) out_info.data;
-
-  ptrs = g_malloc (sizeof (char **) * ref->info.height);
-
-  for (y = 0; y < ref->info.height; y++) {
-    ptrs[y] = ref_info.data + (ref->info.width * 4 * y);
-  }
-
-  ref_image =
-      dssim_create_image (attr, ptrs, DSSIM_RGBA, ref->info.width,
-      ref->info.height, 0.45455);
-
-  ptrs2 = g_malloc (sizeof (char **) * cmp->info.height);
-
-  for (y = 0; y < cmp->info.height; y++) {
-    ptrs2[y] = cmp_info.data + (cmp->info.width * 4 * y);
-  }
-
-  cmp_image =
-      dssim_create_image (attr, ptrs2, DSSIM_RGBA, cmp->info.width,
-      cmp->info.height, 0.45455);
-  dssim = dssim_compare (attr, ref_image, cmp_image);
-
-  map_meta = dssim_pop_ssim_map (attr, 0, 0);
-
-  /* Comparing floats... should not be a big deal anyway */
-  if (self->ssim_threshold > 0 && dssim > self->ssim_threshold) {
-    /* We do not really care about our state... we are going to error ou
-     * anyway! */
-    GST_OBJECT_UNLOCK (self);
-
-    GST_ELEMENT_ERROR (self, STREAM, FAILED,
-        ("Dssim check failed on %s at %"
-            GST_TIME_FORMAT " with dssim %f > %f",
-            padname,
-            GST_TIME_ARGS (GST_AGGREGATOR_PAD (GST_AGGREGATOR (self)->
-                    srcpad)->segment.position), dssim, self->ssim_threshold),
-        (NULL));
-
-    GST_OBJECT_LOCK (self);
-
-    ret = FALSE;
-    goto cleanup_return;
-  }
-
-  if (dssim > self->max_dssim) {
-    map = map_meta.data;
-
-    for (i = 0; i < map_meta.width * map_meta.height; i++) {
-      const float max = 1.0 - map[i];
-      const float maxsq = max * max;
-      out[i] = (dssim_rgba) {
-      .r = to_byte (max * 3.0),.g = to_byte (maxsq * 6.0),.b =
-            to_byte (max / ((1.0 - map_meta.dssim) * 4.0)),.a = 255,};
-    }
-    self->max_dssim = dssim;
-  }
-
-  gst_structure_set (dssim_structure, padname, G_TYPE_DOUBLE, dssim, NULL);
-  gst_structure_set (msg_structure, "dssim", GST_TYPE_STRUCTURE,
-      dssim_structure, NULL);
-
-  ret = TRUE;
-
-cleanup_return:
-
-  gst_structure_free (dssim_structure);
-
-  free (map_meta.data);
-  g_free (ptrs);
-  g_free (ptrs2);
-  gst_buffer_unmap (ref->buffer, &ref_info);
-  gst_buffer_unmap (cmp->buffer, &cmp_info);
-  gst_buffer_unmap (outbuf, &out_info);
-  dssim_dealloc_image (ref_image);
-  dssim_dealloc_image (cmp_image);
-  dssim_dealloc_attr (attr);
-
-  return ret;
-}
-#endif
-
-static gboolean
-compare_frames (GstIqa * self, GstVideoFrame * ref, GstVideoFrame * cmp,
-    GstBuffer * outbuf, GstStructure * msg_structure, gchar * padname)
-{
-#ifdef HAVE_DSSIM
-  if (self->do_dssim) {
-    if (!do_dssim (self, ref, cmp, outbuf, msg_structure, padname))
-      return FALSE;
-  }
-#endif
-
-  return TRUE;
-}
-
-static GstFlowReturn
-gst_iqa_aggregate_frames (GstVideoAggregator * vagg, GstBuffer * outbuf)
-{
-  GList *l;
-  GstVideoFrame *ref_frame = NULL;
-  GstIqa *self = GST_IQA (vagg);
-  GstStructure *msg_structure = gst_structure_new_empty ("IQA");
-  GstMessage *m = gst_message_new_element (GST_OBJECT (self), msg_structure);
-  GstAggregator *agg = GST_AGGREGATOR (vagg);
-
-  if (self->do_dssim) {
-    gst_structure_set (msg_structure, "dssim", GST_TYPE_STRUCTURE,
-        gst_structure_new_empty ("dssim"), NULL);
-    self->max_dssim = 0.0;
-  }
-
-  GST_OBJECT_LOCK (vagg);
-  for (l = GST_ELEMENT (vagg)->sinkpads; l; l = l->next) {
-    GstVideoAggregatorPad *pad = l->data;
-    GstVideoFrame *prepared_frame =
-        gst_video_aggregator_pad_get_prepared_frame (pad);
-
-    if (prepared_frame != NULL) {
-      if (!ref_frame) {
-        ref_frame = prepared_frame;
-      } else {
-        gboolean res;
-        gchar *padname = gst_pad_get_name (pad);
-        GstVideoFrame *cmp_frame = prepared_frame;
-
-        res = compare_frames (self, ref_frame, cmp_frame, outbuf, msg_structure,
-            padname);
-        g_free (padname);
-
-        if (!res)
-          goto failed;
-      }
-    } else if ((self->mode & GST_IQA_MODE_STRICT) && ref_frame) {
-      GST_OBJECT_UNLOCK (vagg);
-
-      GST_ELEMENT_ERROR (self, STREAM, FAILED,
-          ("All sources are supposed to have the same number of buffers"
-              " but got no buffer matching %" GST_PTR_FORMAT " on pad: %"
-              GST_PTR_FORMAT, outbuf, pad), (NULL));
-
-      GST_OBJECT_LOCK (vagg);
-      break;
-    }
-  }
-
-  GST_OBJECT_UNLOCK (vagg);
-
-  /* We only post the message here, because we can't post it while the object
-   * is locked.
-   */
-  gst_structure_set (msg_structure, "time", GST_TYPE_CLOCK_TIME,
-      GST_AGGREGATOR_PAD (agg->srcpad)->segment.position, NULL);
-  gst_element_post_message (GST_ELEMENT (self), m);
-  return GST_FLOW_OK;
-
-failed:
-  GST_OBJECT_UNLOCK (vagg);
-
-  return GST_FLOW_ERROR;
-}
-
-static void
-_set_property (GObject * object, guint prop_id, const GValue * value,
-    GParamSpec * pspec)
-{
-  GstIqa *self = GST_IQA (object);
-
-  switch (prop_id) {
-    case PROP_DO_SSIM:
-      GST_OBJECT_LOCK (self);
-      self->do_dssim = g_value_get_boolean (value);
-      GST_OBJECT_UNLOCK (self);
-      break;
-    case PROP_SSIM_ERROR_THRESHOLD:
-      GST_OBJECT_LOCK (self);
-      self->ssim_threshold = g_value_get_double (value);
-      GST_OBJECT_UNLOCK (self);
-      break;
-    case PROP_MODE:
-      GST_OBJECT_LOCK (self);
-      self->mode = g_value_get_flags (value);
-      GST_OBJECT_UNLOCK (self);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-  }
-}
-
-static void
-_get_property (GObject * object,
-    guint prop_id, GValue * value, GParamSpec * pspec)
-{
-  GstIqa *self = GST_IQA (object);
-
-  switch (prop_id) {
-    case PROP_DO_SSIM:
-      GST_OBJECT_LOCK (self);
-      g_value_set_boolean (value, self->do_dssim);
-      GST_OBJECT_UNLOCK (self);
-      break;
-    case PROP_SSIM_ERROR_THRESHOLD:
-      GST_OBJECT_LOCK (self);
-      g_value_set_double (value, self->ssim_threshold);
-      GST_OBJECT_UNLOCK (self);
-      break;
-    case PROP_MODE:
-      GST_OBJECT_LOCK (self);
-      g_value_set_flags (value, self->mode);
-      GST_OBJECT_UNLOCK (self);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-  }
-}
-
-/* GObject boilerplate */
-static void
-gst_iqa_class_init (GstIqaClass * klass)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
-  GstElementClass *gstelement_class = (GstElementClass *) klass;
-  GstVideoAggregatorClass *videoaggregator_class =
-      (GstVideoAggregatorClass *) klass;
-
-  videoaggregator_class->aggregate_frames = gst_iqa_aggregate_frames;
-
-  gst_element_class_add_static_pad_template_with_gtype (gstelement_class,
-      &src_factory, GST_TYPE_AGGREGATOR_PAD);
-  gst_element_class_add_static_pad_template_with_gtype (gstelement_class,
-      &sink_factory, GST_TYPE_VIDEO_AGGREGATOR_CONVERT_PAD);
-
-  gobject_class->set_property = _set_property;
-  gobject_class->get_property = _get_property;
-
-#ifdef HAVE_DSSIM
-  g_object_class_install_property (gobject_class, PROP_DO_SSIM,
-      g_param_spec_boolean ("do-dssim", "do-dssim",
-          "Run structural similarity checks", FALSE, G_PARAM_READWRITE));
-
-  g_object_class_install_property (gobject_class, PROP_SSIM_ERROR_THRESHOLD,
-      g_param_spec_double ("dssim-error-threshold", "dssim error threshold",
-          "dssim value over which the element will post an error message on the bus."
-          " A value < 0.0 means 'disabled'.",
-          -1.0, G_MAXDOUBLE, DEFAULT_DSSIM_ERROR_THRESHOLD, G_PARAM_READWRITE));
-#endif
-
-  /**
-   * iqa:mode:
-   *
-   * Controls the frame comparison mode.
-   *
-   * Since: 1.18
-   */
-  g_object_class_install_property (gobject_class, PROP_MODE,
-      g_param_spec_flags ("mode", "IQA mode",
-          "Controls the frame comparison mode.", GST_TYPE_IQA_MODE,
-          0, G_PARAM_READWRITE));
-
-  gst_type_mark_as_plugin_api (GST_TYPE_IQA_MODE, 0);
-
-  gst_element_class_set_static_metadata (gstelement_class, "Iqa",
-      "Filter/Analyzer/Video",
-      "Provides various Image Quality Assessment metrics",
-      "Mathieu Duponchelle <mathieu.duponchelle@collabora.co.uk>");
-}
-
-static void
-gst_iqa_init (GstIqa * self)
-{
-}
-
-static gboolean
-plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (gst_iqa_debug, "iqa", 0, "iqa");
-
-  return gst_element_register (plugin, "iqa", GST_RANK_PRIMARY, GST_TYPE_IQA);
-}
-
-GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
-    GST_VERSION_MINOR,
-    iqa,
-    "Iqa", plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME,
-    GST_PACKAGE_ORIGIN)
diff --git a/ext/iqa/iqa.h b/ext/iqa/iqa.h
deleted file mode 100644
index 5c0eb7f..0000000
--- a/ext/iqa/iqa.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* Image Quality Assessment plugin
- * Copyright (C) 2015 Mathieu Duponchelle <mathieu.duponchelle@collabora.co.uk>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- */
-
-#ifndef __GST_IQA_H__
-#define __GST_IQA_H__
-
-#include <gst/gst.h>
-#include <gst/video/video.h>
-#include <gst/video/gstvideoaggregator.h>
-
-G_BEGIN_DECLS
-
-#define GST_TYPE_IQA (gst_iqa_get_type())
-#define GST_IQA(obj) \
-        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IQA, GstIqa))
-#define GST_IQA_CLASS(klass) \
-        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IQA, GstIqaClass))
-#define GST_IS_IQA(obj) \
-        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IQA))
-#define GST_IS_IQA_CLASS(klass) \
-        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IQA))
-
-typedef struct _GstIqa GstIqa;
-typedef struct _GstIqaClass GstIqaClass;
-
-/**
- * GstIqa:
- *
- * The opaque #GstIqa structure.
- */
-struct _GstIqa
-{
-  GstVideoAggregator videoaggregator;
-
-  gboolean do_dssim;
-  gdouble ssim_threshold;
-  gdouble max_dssim;
-  gint mode;
-};
-
-struct _GstIqaClass
-{
-  GstVideoAggregatorClass parent_class;
-};
-
-GType gst_iqa_get_type (void);
-
-G_END_DECLS
-#endif /* __GST_IQA_H__ */
-
diff --git a/ext/iqa/iqaplugin.c b/ext/iqa/iqaplugin.c
new file mode 100644
index 0000000..bacd576
--- /dev/null
+++ b/ext/iqa/iqaplugin.c
@@ -0,0 +1,55 @@
+/* Image Quality Assessment plugin
+ * Copyright (C) 2019 Sergey Zvezdakov <szvezdakov@graphics.cs.msu.ru>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gst/gst.h>
+#ifdef HAVE_DSSIM
+#include "iqa-dssim.h"
+#endif
+#ifdef HAVE_LIBVMAF
+#include "iqa-vmaf.h"
+#endif
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  gboolean result = TRUE;
+
+#ifdef HAVE_DSSIM
+  result &=
+      gst_element_register (plugin, "iqa-dssim", GST_RANK_PRIMARY,
+      GST_TYPE_IQADSSIM);
+#endif
+#ifdef HAVE_LIBVMAF
+  result &=
+      gst_element_register (plugin, "iqa-vmaf", GST_RANK_PRIMARY,
+      GST_TYPE_IQAVMAF);
+#endif
+
+  return result;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    iqa,
+    "Iqa", plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME,
+    GST_PACKAGE_ORIGIN)
diff --git a/ext/iqa/libvmaf_wrapper.cpp b/ext/iqa/libvmaf_wrapper.cpp
new file mode 100644
index 0000000..d1256b9
--- /dev/null
+++ b/ext/iqa/libvmaf_wrapper.cpp
@@ -0,0 +1,127 @@
+/* VMAF Image Quality Assessment plugin
+ * Copyright (C) 2019 Sergey Zvezdakov <szvezdakov@graphics.cs.msu.ru>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+
+#include <libvmaf.h>
+#include <cpu.h>
+#include "libvmaf_wrapper.h"
+
+extern enum vmaf_cpu cpu;
+
+gboolean
+RunVMAF(VMAFReadingFunction read_frame, void *user_data,
+  GstIqaVmafThreadHelper * thread_helper)
+{
+  int width = thread_helper->frame_width;
+  int height = thread_helper->frame_height;
+  const char * model_path = thread_helper->gst_iqavmaf_p->model_filename;
+  const char * fmt;
+  GstIqaVmafPoolMethodEnum pool_method = thread_helper->gst_iqavmaf_p->pool_method;
+  int n_subsample = thread_helper->gst_iqavmaf_p->subsample;
+
+  if (thread_helper->y10bit)
+    fmt = "yuv420p10le";
+  else
+    fmt = "yuv420p";
+
+  if (thread_helper->gst_iqavmaf_p->vmaf_config_disable_avx)
+  {
+    cpu = VMAF_CPU_NONE;
+  } else {
+    cpu = cpu_autodetect();
+  }
+
+  Result result;
+  try {
+    Asset asset(width, height, fmt);
+    std::unique_ptr<IVmafQualityRunner> runner_ptr =
+        VmafQualityRunnerFactory::createVmafQualityRunner(
+        model_path, thread_helper->gst_iqavmaf_p->vmaf_config_conf_int);
+    result = runner_ptr->run(asset, read_frame, user_data,
+        thread_helper->gst_iqavmaf_p->vmaf_config_disable_clip,
+        (thread_helper->gst_iqavmaf_p->vmaf_config_enable_transform
+          || thread_helper->gst_iqavmaf_p->vmaf_config_phone_model),
+        thread_helper->gst_iqavmaf_p->vmaf_config_psnr,
+        thread_helper->gst_iqavmaf_p->vmaf_config_ssim,
+        thread_helper->gst_iqavmaf_p->vmaf_config_ms_ssim,
+        thread_helper->gst_iqavmaf_p->num_threads,
+        n_subsample);
+  }
+  catch (VmafException& e)
+  {
+    thread_helper->error_msg = g_strconcat ("caughted VmafException - ",
+        e.what(), NULL);
+    return FALSE;
+  }
+  catch (std::runtime_error& e)
+  {
+    thread_helper->error_msg = g_strconcat ("caughted runtime_error - ",
+        e.what(), NULL);
+    return FALSE;
+  }
+  catch (std::logic_error& e)
+  {
+    thread_helper->error_msg = g_strconcat ("caughted logic_error - ",
+        e.what(), NULL);
+    return FALSE;
+  }
+  catch (std::exception& e)
+  {
+    thread_helper->error_msg = g_strconcat ("caughted exception - ",
+        e.what(), NULL);
+    return FALSE;
+  }
+  catch (...)
+  {
+    thread_helper->error_msg = g_strconcat ("caughted Unknown exception!",
+        NULL);
+    return FALSE;
+  }
+  switch (pool_method) {
+    case MIN_POOL_METHOD:
+      result.setScoreAggregateMethod(ScoreAggregateMethod::MINIMUM);;
+      break;
+    case MEAN_POOL_METHOD:
+      result.setScoreAggregateMethod(ScoreAggregateMethod::MEAN);
+      break;
+    case HARMONIC_MEAN_POOL_METHOD:
+      result.setScoreAggregateMethod(ScoreAggregateMethod::HARMONIC_MEAN);
+      break;
+  }
+  std::vector<std::string> result_keys = result.get_keys();
+
+  uint num_frames_subsampled = result.get_scores("vmaf").size();
+  for (uint i_subsampled=0; i_subsampled<num_frames_subsampled; i_subsampled++)
+  {
+    GstStructure *frame_result_str = gst_structure_new_empty ("IQA-VMAF");
+    GstMessage *msg = gst_message_new_element (GST_OBJECT (thread_helper->gst_iqavmaf_p), frame_result_str);
+    GstStructure *metrics_data_str = gst_structure_new_empty ("metrics");
+    gst_structure_set (frame_result_str, "padname", G_TYPE_STRING, thread_helper->padname, NULL);
+    gst_structure_set (frame_result_str, "frame_num", G_TYPE_UINT, i_subsampled * n_subsample, NULL);
+    for (size_t j = 0; j < result_keys.size(); j++)
+    {
+      double value = result.get_scores(result_keys[j].c_str()).at(i_subsampled);
+      gst_structure_set (metrics_data_str, result_keys[j].c_str(), G_TYPE_DOUBLE, value, NULL);
+    }
+    gst_structure_set (frame_result_str, "metrics", GST_TYPE_STRUCTURE, metrics_data_str, NULL);
+    gst_structure_free (metrics_data_str);
+    gst_element_post_message (GST_ELEMENT (thread_helper->gst_iqavmaf_p), msg);
+  }
+  return TRUE;
+}
diff --git a/ext/iqa/libvmaf_wrapper.h b/ext/iqa/libvmaf_wrapper.h
new file mode 100644
index 0000000..4d34254
--- /dev/null
+++ b/ext/iqa/libvmaf_wrapper.h
@@ -0,0 +1,33 @@
+/* VMAF Image Quality Assessment plugin
+ * Copyright (C) 2019 Sergey Zvezdakov <szvezdakov@graphics.cs.msu.ru>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "iqa-vmaf.h"
+
+typedef int (*VMAFReadingFunction)(float *ref_data, float *main_data,
+	float *temp_data, int stride, void *user_data);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+gboolean
+RunVMAF(VMAFReadingFunction read_frame, void *user_data,
+    GstIqaVmafThreadHelper *thread_helper);
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/ext/iqa/meson.build b/ext/iqa/meson.build
index 75e07fc..2229f9a 100644
--- a/ext/iqa/meson.build
+++ b/ext/iqa/meson.build
@@ -1,14 +1,38 @@
 dssim_dep = dependency('dssim', required : get_option('iqa'),
     fallback: ['dssim', 'dssim_dep'])
 
-if dssim_dep.found()
+libvmaf_dep = dependency('libvmaf', required : get_option('iqa'),
+    fallback: ['vmaf', 'libvmaf_dep'])
+
+gstiqa_dssim_detected = dssim_dep.found()
+gstiqa_libvmaf_detected = libvmaf_dep.found()
+gstiqa_sources_list = ['iqaplugin.c']
+gstiqa_c_args = gst_plugins_bad_args + ['-DGST_USE_UNSTABLE_API']
+gstiqa_dependencies_list = [gstvideo_dep, gstbase_dep, gst_dep]
+gstiqa_override_options = []
+
+if gstiqa_dssim_detected
+  gstiqa_sources_list += ['iqa-dssim.c']
+  gstiqa_dependencies_list += [dssim_dep]
+  gstiqa_c_args += ['-DHAVE_DSSIM']
+endif
+
+if gstiqa_libvmaf_detected
+  gstiqa_sources_list += ['iqa-vmaf.c', 'libvmaf_wrapper.cpp']
+  gstiqa_dependencies_list += [libvmaf_dep]
+  gstiqa_c_args += ['-DHAVE_LIBVMAF']
+  gstiqa_override_options += ['cpp_std=c++11']
+endif
+
+if gstiqa_dssim_detected or gstiqa_libvmaf_detected
   gstiqa = library('gstiqa',
-    'iqa.c',
-    c_args : gst_plugins_bad_args + ['-DGST_USE_UNSTABLE_API', '-DHAVE_DSSIM'],
+    gstiqa_sources_list,
+    c_args : gstiqa_c_args,
     include_directories : [configinc],
-    dependencies : [gstvideo_dep, gstbase_dep, gst_dep, dssim_dep],
+    dependencies : gstiqa_dependencies_list,
     install : true,
     install_dir : plugins_install_dir,
+    override_options : gstiqa_override_options,
   )
   pkgconfig.generate(gstiqa, install_dir : plugins_pkgconfig_install_dir)
   plugins += [gstiqa]
diff --git a/meson.build b/meson.build
index d43229f..6bc8ad5 100644
--- a/meson.build
+++ b/meson.build
@@ -461,6 +461,7 @@ if get_option('default_library') == 'shared'
   plugins_pkgconfig_install_dir = disabler()
 endif
 
+subproject('vmaf')
 subdir('gst-libs')
 subdir('gst')
 subdir('sys')
-- 
1.8.3.1

